/*	CLASS MESH
 * 
 * Generic mesh class with templates
 * Lnode: node-list vector of the mesh
 * Lfinel: finite element-list of the mesh
 * 
 * A mesh of finite element is a list of finite element T,
 * where T can be any type of it: square Q1, triangles P1, ...
 * 
 * The best thing of a list is that we can change it easily: add, remove elements, etc
 * Highly recommended for dynamic mesh refinement
 */
#ifndef __MESH_
#define __MESH_

#include "header.h"
#include <list>
#include <vector>
#include "point.h"
#include "qelfin.h" // In case we want to use Q1 elements
#include "pelfin.h"
#include "data.h"
#include <Eigen/Dense>

using namespace Eigen;

class data;

template < typename T >
class Mfinel:public T{
public :
    // Atributes:
    friend class data;
    static int Nnodes;  // Number of nodes
    static int Nfinel; // Number of finite elements
    vector<point*> Lnode; // Node-list
    list<T> Lfinel; // Element-List
    double bcDirc; // Dirichlet Boundary Condition
    // Atributes: Eigen
    MatrixXf A;
    VectorXf b;
    // Constructor
    Mfinel();
    ~Mfinel();
    // Methods
    void fill_mesh(data& Data); // fill the mesh
    void print_nodes();
    void print_elements();
    void build_matrix_global();
    void solve();
};
template < typename T >
Mfinel<T>::Mfinel(){
  cout <<"Summonnig constructor of Mfinel"<< endl ;
  vector<point*> Lnode; // List of nodes
  this->Nnodes=0;
  this->Nfinel=0.;
  this->bcDirc=0.; // Value of the Dirichlet boundary condition
}
template < typename T >
Mfinel<T>::~Mfinel(){
  cout <<"Summonnig destructor of Mfinel"<< endl ;
}
// Define the static atributes
template <typename T> int Mfinel<T>::Nnodes;
template <typename T> int Mfinel<T>::Nfinel;
// Method that fill the mesh through data from a file, generated by a mesher
// or by of own mesh code.
template < typename T >
void Mfinel<T>::fill_mesh(data& Data){
  cout<<"FILL THE NODE-LIST"<<endl;
  ifstream myfile (Data.mesh.nodes.c_str()); // Attention!: we have to convert the string to a pointer of char -> c_str
  if (myfile.is_open()){
    while (myfile.good() ){
      point *node=new point();   // New node
      myfile>>node->x>>node->y;  // Assign of the coordinates
      this->Nnodes++;            // Increment in one the number of nodes
      node->ind = Nnodes;	  // Asign of the index to the node
      cout<<"Number of nodes: "<<this->Nnodes<<endl
	  <<"("<<node->x<<", "<<node->y<<")"<<endl; // Print x and y
      this->Lnode.push_back(node); // Insert the node in node-list
    }
    myfile.close();
    cout<<"-------------------------------------------"<<endl;
  }
  // Boundary nodes
  myfile.open("mesh/mesh_bnd_node.dat");
  if (myfile.is_open()){
    while (myfile.good()){
      int ind;
      for(int i=0;i<Lnode.size();i++){
	myfile>>ind;
	this->Lnode[ind-1]->bound = 1; //Cond. Dirichlet
      }
    }
    myfile.close();
  }
  double total=0.; // Check total area
  cout<<"FILL THE ELEMENT-LIST"<<endl;
  myfile.open("mesh/mesh_tnode.dat");
  if (myfile.is_open()){
    while ( myfile.good()){
      cout<<endl;
      T Elmt=T();  // New temporal element
      cout<<"Insert of the element "<<this->Nfinel+1<<endl;
      for(int k=0;k<Elmt.N;k++){ // Read of the conectivity
	int connect;
	myfile>>connect;
	cout<<"Conectivity: "<<connect;
        Elmt.V[k]=this->Lnode[connect-1]; //Assign REFERENCE to the correspond point
        // ATTENTION: SAME MEMORY PATH (we don't copy the content of the point)
	cout<<" || memory path: "<<(Elmt.V[k])<<" "<<(this->Lnode[connect-1])<<endl;
      }
      this->Nfinel++;
      Elmt.connect_area();
      total += Elmt.area; // Check total area
      this->Lfinel.push_back(Elmt); // Insert the element in element-list
      cout<<endl;
    }
    cout<<"-------------------------------------------"<<endl
	<<"CHECK TOTAL AREA: "<<total<<endl; // Check total area
    myfile.close();
  }
  cout<<"-------------------------------------------"<<endl;
}
// Print node-list of the mesh
template < typename T >
void Mfinel<T>::print_nodes(){
  cout<<"PRINT NODES OF THE MESH:"<<endl;
  int i=0;
  vector<point*>::iterator it; // node-list iterator
  for(it=this->Lnode.begin(); it != this->Lnode.end(); ++it){
    cout<<"NODE "<<i+1<<endl;
    (*it)->print_point(); // Other way:  (*(*it)).print_points();
    i++;
  }
  cout<<"-------------------------------------------"<<endl;
}
// Print element-list of the mesh
template < typename T >
void Mfinel<T>::print_elements(){
  cout<<"PRINT ELEMENTS OF THE MESH:"<<endl<<endl;
  int i=0;
//   list<T>::iterator it; // Wrong!: the iterator of element-list does not know T
  typename list<T>::iterator it; // Attention! without typename- iterator gives error!
  for(it=this->Lfinel.begin(); it != this->Lfinel.end(); ++it){
    cout<<"ELEMENT "<<i+1<<endl;
    it->print_finel(); // Other way:  (*(*it)).print_points();
    i++;
  }
  cout<<"-------------------------------------------"<<endl;
}
// Builder global matrix and the independent vector
template < typename T >
void Mfinel<T>::build_matrix_global(){
  cout<<"MATRIX GLOBAL CONSTRUCTION:"<<endl;
  double sum;
  // Declaracion variables tipo Eigen
  this->A.resize(this->Nnodes,this->Nnodes);
  this->b.resize(this->Nnodes);
  // Inicializate to 0 (Eigen advance inicialization)
  this->A = MatrixXf::Zero(this->Nnodes,this->Nnodes);
  this->b = VectorXf::Zero(this->Nnodes);
  // Adding contribution of the local to the global matrix
  typename list<T>::iterator it; // Define of the iterator type <T>
  for (it=this->Lfinel.begin();it!=this->Lfinel.end();++it){
    it->solve_matrix_local(this->A);
    for (int i=0;i<it->N;i++){
      // Fix of the boundary conditions
      if (it->V[i]->bound==1){
	this->A(it->V[i]->ind-1,it->V[i]->ind-1) = pow(10,3);
	this->b(it->V[i]->ind-1) = pow(10,5)*this->bcDirc;
      }
      else{
	sum=0.;
	for(int j=0;j<it->N;j++){
	  sum += it->phi(it->V[j]->x,it->V[j]->y)*f(it->V[j]->x,it->V[j]->y);
	}
	  b(it->V[i]->ind-1) += (it->area*sum)/(3.);
      }
    }
  }
}
// Solve the linear system
template < typename T >
void Mfinel<T>::solve(){
  cout<<"SOLVING LINEAR SYSTEM"<<endl
      <<"-------------------------------------------"<<endl;
  build_matrix_global();// Summoning: build_matrix_global
  // Solving by QR method
  VectorXf x(this->Nnodes);
  x = this->A.colPivHouseholderQr().solve(this->b);
  save(x);
  cout<<"-------------------------------------------"<<endl;
}
#endif